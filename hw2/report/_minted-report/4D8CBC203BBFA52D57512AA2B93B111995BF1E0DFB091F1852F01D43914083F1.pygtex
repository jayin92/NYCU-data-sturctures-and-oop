\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}ifndef PARTI\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZdq{}SolverBase.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{PartI} \PYG{o}{:} \PYG{k}{public} \PYG{n}{SolverBase}
\PYG{p}{\PYGZob{}}
\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{n}{cnt}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}\PYGZgt{}\PYGZgt{}} \PYG{n}{graph}\PYG{p}{;} \PYG{c+c1}{// Declare an adjacency list to save the graph (pair fisrt: vertex second: weight)}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}\PYGZgt{}\PYGZgt{}} \PYG{n}{rev\PYGZus{}graph}\PYG{p}{;} \PYG{c+c1}{// Declare an adjacency list to save the \PYGZdq{}reverse\PYGZdq{} graph (pair fisrt: vertex second: weight)}
\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{scc\PYGZus{}graph}\PYG{p}{;}  \PYG{c+c1}{// Use map to save edges and theirs weights}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}\PYGZgt{}\PYGZgt{}} \PYG{n}{scc\PYGZus{}vertex}\PYG{p}{;} \PYG{c+c1}{// Save the id of each vertices in every SCC}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{order}\PYG{p}{;} \PYG{c+c1}{// Save topological order}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{scc}\PYG{p}{;} \PYG{c+c1}{// Save the id of corresponding SCC of each vertex}

\PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{finish}\PYG{p}{;} \PYG{c+c1}{// Store the status of vertex when traversing}
\PYG{k+kt}{bool} \PYG{n}{isAyclic} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;} \PYG{c+c1}{// To store that this graph is acyclic or not}

\PYG{k}{public}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{n}{read}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{p}{);} \PYG{c+c1}{// Read input from file}
    \PYG{k+kt}{void} \PYG{n+nf}{solve}\PYG{p}{();} \PYG{c+c1}{// Main solve function}
    \PYG{k+kt}{void} \PYG{n+nf}{write}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{p}{);} \PYG{c+c1}{// Write output to file}
    \PYG{k+kt}{void} \PYG{n+nf}{dfs}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{);} \PYG{c+c1}{// DFS}
    \PYG{k+kt}{void} \PYG{n+nf}{scc\PYGZus{}dfs}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{);} \PYG{c+c1}{// Run dfs to get SCC}
    \PYG{k+kt}{void} \PYG{n+nf}{scc\PYGZus{}revdfs}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{);} \PYG{c+c1}{// Run reverse dfs to get SCC}
    \PYG{k+kt}{void} \PYG{n+nf}{kosaraju}\PYG{p}{();} \PYG{c+c1}{// The main part of Kosaraju\PYGZsq{}s Algorithm}
    \PYG{k+kt}{void} \PYG{n+nf}{buildGraph}\PYG{p}{();} \PYG{c+c1}{// Build coarse graph}
    \PYG{k+kt}{void} \PYG{n+nf}{buildGraphDFS}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{);} \PYG{c+c1}{// Use dfs to build the coarse graph}
\PYG{p}{\PYGZcb{};}

\PYG{c+cp}{\PYGZsh{}define PARTI\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}endif}
\end{Verbatim}
